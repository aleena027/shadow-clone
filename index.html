<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voice Assistant</title>
  <link rel="manifest" href="/shadow-clone/manifest.json">
  <meta name="theme-color" content="#3b82f6">
  <link rel="stylesheet" href="/shadow-clone/styles.css">
</head>
<body>
  <div id="loginPage" class="container">
    <h1>Login / Register</h1>
    <input id="emailInput" type="email" placeholder="Enter email">
    <button id="sendOtpBtn">Send OTP</button>
    <button id="skipLoginBtn">Skip Sign-In</button>
    <div id="otpSection" class="hidden">
      <input id="otpInput" type="text" placeholder="Enter OTP">
      <button id="verifyOtpBtn">Verify OTP</button>
    </div>
    <div id="loginStatus"></div>
  </div>
  <div id="mainPage" class="container hidden">
    <div class="header">
      <h1>Voice Assistant</h1>
      <button id="logoutBtn">Logout</button>
    </div>
    <button id="recordBtn">Start Recording</button>
    <div id="status"></div>
    <div id="transcription"></div>
    <div class="tabs">
      <button id="allTab">All</button>
      <button id="notesTab">Notes</button>
      <button id="remindersTab">Reminders</button>
      <button id="historyTab">History</button>
    </div>
    <div id="items"></div>
    <div id="editReminderForm" class="hidden">
      <input id="editText" type="text" placeholder="Item text">
      <input id="editTime" type="datetime-local" class="optional">
      <button id="saveEditBtn">Save</button>
    </div>
  </div>

  <script type="module">
    import * as transformers from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.0.0/dist/transformers.min.js';

    function init() {
      const loginPage = document.getElementById('loginPage');
      const mainPage = document.getElementById('mainPage');
      const emailInput = document.getElementById('emailInput');
      const sendOtpBtn = document.getElementById('sendOtpBtn');
      const skipLoginBtn = document.getElementById('skipLoginBtn');
      const otpSection = document.getElementById('otpSection');
      const otpInput = document.getElementById('otpInput');
      const verifyOtpBtn = document.getElementById('verifyOtpBtn');
      const loginStatus = document.getElementById('loginStatus');
      const logoutBtn = document.getElementById('logoutBtn');
      const recordBtn = document.getElementById('recordBtn');
      const status = document.getElementById('status');
      const transcription = document.getElementById('transcription');
      const items = document.getElementById('items');
      const allTab = document.getElementById('allTab');
      const notesTab = document.getElementById('notesTab');
      const remindersTab = document.getElementById('remindersTab');
      const historyTab = document.getElementById('historyTab');
      const editReminderForm = document.getElementById('editReminderForm');
      const editText = document.getElementById('editText');
      const editTime = document.getElementById('editTime');
      const saveEditBtn = document.getElementById('saveEditBtn');
      let isRecording = false;
      let mediaRecorder;
      let recognition;
      let currentEmail = localStorage.getItem('currentEmail') || '';
      const audio = new Audio('/shadow-clone/alert.mp3');

      if (!window.isSecureContext) {
        loginStatus.textContent = 'Error: This app requires HTTPS or localhost.';
        sendOtpBtn.disabled = true;
        skipLoginBtn.disabled = true;
        recordBtn.disabled = true;
        return;
      }

      navigator.permissions.query({ name: 'microphone' }).then(result => {
        status.textContent = `Microphone permission: ${result.state}`;
        if (result.state !== 'granted') {
          status.textContent += ' Please allow microphone access.';
        }
      });

      if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
        recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = 'en-US';
      } else {
        loginStatus.textContent = 'Error: Web Speech API not supported. Please use Chrome.';
        sendOtpBtn.disabled = true;
        skipLoginBtn.disabled = true;
        recordBtn.disabled = true;
        return;
      }

      if (navigator.storage && navigator.storage.persist) {
        navigator.storage.persist().then(isPersisted => {
          console.log(`Persistent storage: ${isPersisted}`);
        });
      }

      let classifier;
      (async () => {
        try {
          classifier = await transformers.pipeline('text-classification', 'distilbert/distilbert-base-uncased-finetuned-sst-2-english', {
            modelPath: 'onnx/model.onnx'
          });
          status.textContent = 'AI model loaded successfully';
        } catch (err) {
          console.error('Model loading error:', err);
          status.textContent = 'AI model failed to load. Using regex-based classification.';
          classifier = null;
        }
      })();

      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/shadow-clone/sw.js').then(reg => {
          console.log('Service Worker Registered');
          subscribeToPush(reg);
        }).catch(err => {
          console.error('Service Worker Error:', err);
          status.textContent = `Service Worker Error: ${err.message}`;
        });
      }

      async function subscribeToPush(registration) {
        try {
          const subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: 'YOUR_VAPID_PUBLIC_KEY' // Replace with your VAPID public key
          });
          await fetch('https://shadow-clone.onrender.com/subscribe-push', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: currentEmail || 'guest', subscription })
          });
          console.log('Push subscription sent to server');
        } catch (err) {
          console.error('Push subscription error:', err);
          status.textContent = 'Push notifications not enabled. Using in-app notifications.';
        }
      }

      if (currentEmail) {
        loginPage.classList.add('hidden');
        mainPage.classList.remove('hidden');
        loadItems();
        scheduleReminders();
      } else {
        loginPage.classList.remove('hidden');
        mainPage.classList.add('hidden');
      }

      sendOtpBtn.addEventListener('click', async () => {
        const email = emailInput.value.trim();
        if (!email || !email.includes('@')) {
          loginStatus.textContent = 'Please enter a valid email.';
          return;
        }
        try {
          const response = await fetch('https://shadow-clone.onrender.com/send-otp', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email })
          });
          const data = await response.json();
          if (data.success) {
            loginStatus.textContent = 'OTP sent to email.';
            otpSection.classList.remove('hidden');
          } else {
            loginStatus.textContent = 'Error sending OTP: ' + data.message;
          }
        } catch (err) {
          loginStatus.textContent = 'Error connecting to server: ' + err.message;
        }
      });

      skipLoginBtn.addEventListener('click', () => {
        currentEmail = 'guest';
        localStorage.setItem('currentEmail', currentEmail);
        loginPage.classList.add('hidden');
        mainPage.classList.remove('hidden');
        loadItems();
        scheduleReminders();
      });

      verifyOtpBtn.addEventListener('click', async () => {
        const otp = otpInput.value.trim();
        try {
          const response = await fetch('https://shadow-clone.onrender.com/verify-otp', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: emailInput.value.trim(), otp })
          });
          const data = await response.json();
          if (data.success) {
            currentEmail = emailInput.value.trim();
            localStorage.setItem('currentEmail', currentEmail);
            loginPage.classList.add('hidden');
            mainPage.classList.remove('hidden');
            loadItems();
            scheduleReminders();
            loginStatus.textContent = '';
            navigator.serviceWorker.ready.then(reg => subscribeToPush(reg));
          } else {
            loginStatus.textContent = 'Invalid OTP.';
          }
        } catch (err) {
          loginStatus.textContent = 'Error verifying OTP: ' + err.message;
        }
      });

      logoutBtn.addEventListener('click', () => {
        localStorage.removeItem('currentEmail');
        currentEmail = '';
        loginPage.classList.remove('hidden');
        mainPage.classList.add('hidden');
        items.innerHTML = '';
        emailInput.value = '';
        otpInput.value = '';
        otpSection.classList.add('hidden');
        loginStatus.textContent = '';
      });

      function loadItems(filter = 'all') {
        const stored = JSON.parse(localStorage.getItem(`voiceItems_${currentEmail}`) || '[]');
        items.innerHTML = '';
        let filtered = [];
        if (filter === 'history') {
          filtered = [
            ...stored.filter(item => item.completed).map(item => ({
              ...item,
              isHistory: true,
              completedAt: item.completedAt || item.timestamp
            })),
            ...stored.flatMap(item =>
              (item.editHistory || []).map(history => ({
                ...item,
                text: history.text,
                reminderTime: history.reminderTime,
                editedAt: history.editedAt,
                isHistory: true
              }))
            )
          ];
        } else {
          filtered = (filter === 'all' ? stored : stored.filter(item => item.type === filter))
            .filter(item => !item.completed);
        }
        filtered.sort((a, b) => (b.editedAt || b.completedAt || b.timestamp) - (a.editedAt || a.completedAt || a.timestamp));
        filtered.forEach(item => {
          const div = document.createElement('div');
          div.className = 'item';
          div.innerHTML = `
            <span>${item.type.toUpperCase()}: ${item.text} (${new Date(item.timestamp).toLocaleString()})${item.reminderTime ? ` (Due: ${new Date(item.reminderTime).toLocaleString()})` : ''}${item.editedAt && item.isHistory ? ` (Edited: ${new Date(item.editedAt).toLocaleString()})` : ''}${item.completedAt && item.isHistory ? ` (Completed: ${new Date(item.completedAt).toLocaleString()})` : ''}</span>
            ${!item.isHistory ? `
              <div>
                <button class="editItem" data-id="${item.id}">Edit</button>
                ${item.type === 'reminder' ? `
                  <button class="addToCalendar" data-id="${item.id}">Add to Calendar</button>
                ` : ''}
                <button class="deleteItem" data-id="${item.id}">Delete</button>
                <button class="completeItem" data-id="${item.id}">Mark as Completed</button>
              </div>` : ''}
          `;
          items.appendChild(div);
        });

        document.querySelectorAll('.editItem').forEach(btn => {
          btn.addEventListener('click', () => {
            const id = btn.dataset.id;
            const item = stored.find(i => i.id == id);
            if (!item) return;
            editText.value = item.text;
            editTime.value = item.reminderTime ? new Date(item.reminderTime).toISOString().slice(0, 16) : '';
            editTime.classList.toggle('optional', item.type === 'note');
            editReminderForm.dataset.id = id;
            editReminderForm.classList.remove('hidden');
            items.classList.add('hidden');
          });
        });

        document.querySelectorAll('.addToCalendar').forEach(btn => {
          btn.addEventListener('click', () => {
            const id = btn.dataset.id;
            const item = stored.find(i => i.id == id);
            if (item) {
              const start = item.reminderTime ? new Date(item.reminderTime) : new Date();
              const end = new Date(start.getTime() + 30 * 60 * 1000);
              const url = `https://www.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(item.text)}&dates=${start.toISOString().replace(/[-:]/g, '').split('.')[0]}Z/${end.toISOString().replace(/[-:]/g, '').split('.')[0]}Z`;
              window.open(url, '_blank');
            }
          });
        });

        document.querySelectorAll('.deleteItem').forEach(btn => {
          btn.addEventListener('click', () => {
            const id = btn.dataset.id;
            deleteItem(id);
          });
        });

        document.querySelectorAll('.completeItem').forEach(btn => {
          btn.addEventListener('click', () => {
            const id = btn.dataset.id;
            markAsCompleted(id);
          });
        });
      }

      function scheduleReminders() {
        const checkReminders = () => {
          const stored = JSON.parse(localStorage.getItem(`voiceItems_${currentEmail}`) || '[]');
          const now = Date.now();
          stored.forEach(item => {
            if (item.type === 'reminder' && item.reminderTime && item.reminderTime <= now && !item.completed) {
              if (Notification.permission === 'granted') {
                new Notification('Reminder', { body: item.text });
                audio.play().catch(err => console.error('Audio error:', err));
              }
              markAsCompleted(item.id);
            }
          });
        };
        checkReminders();
        setInterval(checkReminders, 10 * 1000); // Check every 10 seconds
      }

      function saveItem(item) {
        const stored = JSON.parse(localStorage.getItem(`voiceItems_${currentEmail}`) || '[]');
        item.editHistory = item.editHistory || [];
        item.completed = item.completed || false;
        stored.push(item);
        localStorage.setItem(`voiceItems_${currentEmail}`, JSON.stringify(stored));
        loadItems();
        if (item.type === 'reminder' && item.reminderTime && !item.completed) {
          fetch('https://shadow-clone.onrender.com/schedule-push', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: currentEmail, text: item.text, reminderTime: item.reminderTime, id: item.id })
          }).catch(err => console.error('Schedule push error:', err));
          scheduleReminders();
        }
      }

      function deleteItem(id) {
        const stored = JSON.parse(localStorage.getItem(`voiceItems_${currentEmail}`) || '[]');
        const updated = stored.filter(item => item.id != id);
        localStorage.setItem(`voiceItems_${currentEmail}`, JSON.stringify(updated));
        loadItems();
        transcription.textContent = 'Item deleted';
      }

      function markAsCompleted(id) {
        const stored = JSON.parse(localStorage.getItem(`voiceItems_${currentEmail}`) || '[]');
        const item = stored.find(i => i.id == id);
        if (!item) return;
        item.completed = true;
        item.completedAt = Date.now();
        localStorage.setItem(`voiceItems_${currentEmail}`, JSON.stringify(stored));
        loadItems();
        transcription.textContent = `Item marked as completed: ${item.text}`;
      }

      function updateItem(id, text, reminderTime, isManual = false) {
        const stored = JSON.parse(localStorage.getItem(`voiceItems_${currentEmail}`) || '[]');
        const item = stored.find(i => i.id == id);
        if (!item) return;

        if (!item.originalText) item.originalText = item.text;
        item.editHistory = item.editHistory || [];
        item.editHistory.push({
          text: item.text,
          reminderTime: item.reminderTime,
          editedAt: Date.now()
        });
        item.text = text;
        item.reminderTime = reminderTime;
        item.type = reminderTime ? 'reminder' : 'note';
        localStorage.setItem(`voiceItems_${currentEmail}`, JSON.stringify(stored));
        loadItems();
        if (reminderTime && Notification.permission === 'granted' && !item.completed) {
          fetch('https://shadow-clone.onrender.com/schedule-push', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: currentEmail, text: item.text, reminderTime: item.reminderTime, id: item.id })
          }).catch(err => console.error('Schedule push error:', err));
          scheduleReminders();
        }
        transcription.textContent = `Item updated: ${text}`;
        if (isManual) {
          editReminderForm.classList.add('hidden');
          items.classList.remove('hidden');
        }
      }

      async function checkNotificationPermission() {
        if (Notification.permission === 'default') {
          const result = await Notification.requestPermission();
          return result === 'granted';
        }
        return Notification.permission === 'granted';
      }

      saveEditBtn.addEventListener('click', () => {
        const id = editReminderForm.dataset.id;
        const text = editText.value.trim();
        const reminderTime = editTime.value ? new Date(editTime.value).getTime() : null;
        if (!text) {
          status.textContent = 'Text is required.';
          return;
        }
        updateItem(id, text, reminderTime, true);
      });

      async function processText(text) {
        const lowerText = text.toLowerCase();
        let type = 'note';
        let reminderTime = null;

        if (lowerText.includes('remind') || lowerText.includes('schedule')) {
          type = 'reminder';
        } else if (classifier) {
          try {
            const result = await classifier(lowerText);
            type = result[0].label.includes('POSITIVE') ? 'reminder' : 'note';
          } catch (err) {
            console.error('AI processing error:', err);
            type = lowerText.includes('remind') || lowerText.includes('schedule') ? 'reminder' : 'note';
          }
        }

        const timeMatch = lowerText.match(/(at \d{1,2}(?::\d{2})?\s*(am|pm)|tomorrow|today|next \w+|in \d+\s*(hour|day|week))/i);
        if (timeMatch) {
          type = 'reminder';
          let time;
          const now = new Date();
          if (timeMatch[0].includes('tomorrow')) {
            time = new Date(now.getTime() + 24 * 60 * 60 * 1000);
            time.setHours(0, 0, 0, 0);
          } else if (timeMatch[0].includes('today')) {
            time = new Date();
          } else if (timeMatch[0].includes('next')) {
            time = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
            time.setHours(0, 0, 0, 0);
          } else if (timeMatch[0].includes('in')) {
            const num = parseInt(timeMatch[0].match(/\d+/)[0]);
            const unit = timeMatch[0].match(/hour|day|week/)[0];
            const multiplier = { hour: 3600, day: 24 * 3600, week: 7 * 24 * 3600 }[unit];
            time = new Date(now.getTime() + num * multiplier * 1000);
          } else if (timeMatch[0].includes('at')) {
            const timeStr = timeMatch[0].replace('at ', '').trim();
            time = new Date(`${now.toDateString()} ${timeStr}`);
            if (isNaN(time.getTime())) {
              time = new Date();
            } else if (time.getTime() < now.getTime()) {
              time.setDate(time.getDate() + 1);
            }
          }
          reminderTime = time.getTime();
        }

        const item = {
          id: Date.now(),
          type,
          text,
          timestamp: Date.now(),
          reminderTime,
          originalText: text,
          editHistory: [],
          completed: false
        };
        saveItem(item);
        transcription.textContent = `Saved as ${item.type}: ${text}`;
      }

      recordBtn.addEventListener('click', async () => {
        if (!isRecording) {
          const notificationsAvailable = await checkNotificationPermission();
          if (!notificationsAvailable) {
            status.textContent = 'Notifications not enabled. Reminders may not show.';
          }

          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            mediaRecorder.start();
            recognition.start();

            isRecording = true;
            recordBtn.textContent = 'Stop Recording';
            recordBtn.className = 'button red';
            status.textContent = 'Recording...';

            recognition.onresult = event => {
              const text = event.results[0][0].transcript;
              transcription.textContent = `Transcribed: ${text}`;
              processText(text);
            };

            recognition.onerror = event => {
              status.textContent = `Speech recognition error: ${event.error}`;
              console.error('Speech error:', event.error);
            };

            recognition.onend = () => {
              if (isRecording) {
                mediaRecorder.stop();
                stream.getTracks().forEach(track => track.stop());
                isRecording = false;
                recordBtn.textContent = 'Start Recording';
                recordBtn.className = 'button';
                status.textContent = '';
              }
            };

            mediaRecorder.onstop = () => {
              stream.getTracks().forEach(track => track.stop());
            };
          } catch (err) {
            status.textContent = `Error accessing microphone: ${err.message}`;
            console.error('Microphone error:', err);
          }
        } else {
          mediaRecorder.stop();
          recognition.stop();
        }
      });

      document.addEventListener('click', event => {
        if (event.target.classList.contains('editItem')) {
          const id = event.target.dataset.id;
          status.textContent = 'Speak new item details...';
          recognition.start();
          recognition.onresult = event => {
            const text = event.results[0][0].transcript;
            const lowerText = text.toLowerCase();
            let reminderTime = null;
            const timeMatch = lowerText.match(/(at \d{1,2}(?::\d{2})?\s*(am|pm)|tomorrow|today|next \w+|in \d+\s*(hour|day|week))/i);
            if (timeMatch) {
              let time;
              const now = new Date();
              if (timeMatch[0].includes('tomorrow')) {
                time = new Date(now.getTime() + 24 * 60 * 60 * 1000);
                time.setHours(0, 0, 0, 0);
              } else if (timeMatch[0].includes('today')) {
                time = new Date();
              } else if (timeMatch[0].includes('next')) {
                time = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
                time.setHours(0, 0, 0, 0);
              } else if (timeMatch[0].includes('in')) {
                const num = parseInt(timeMatch[0].match(/\d+/)[0]);
                const unit = timeMatch[0].match(/hour|day|week/)[0];
                const multiplier = { hour: 3600, day: 24 * 3600, week: 7 * 24 * 3600 }[unit];
                time = new Date(now.getTime() + num * multiplier * 1000);
              } else if (timeMatch[0].includes('at')) {
                const timeStr = timeMatch[0].replace('at ', '').trim();
                time = new Date(`${now.toDateString()} ${timeStr}`);
                if (isNaN(time.getTime())) {
                  time = new Date();
                } else if (time.getTime() < now.getTime()) {
                  time.setDate(time.getDate() + 1);
                }
              }
              reminderTime = time.getTime();
            }
            updateItem(id, text, reminderTime);
            recognition.stop();
          };
          recognition.onerror = event => {
            status.textContent = `Speech recognition error: ${event.error}`;
            recognition.stop();
          };
        }
      });

      allTab.addEventListener('click', () => {
        allTab.className = 'tab active';
        notesTab.className = 'tab';
        remindersTab.className = 'tab';
        historyTab.className = 'tab';
        loadItems('all');
      });
      notesTab.addEventListener('click', () => {
        allTab.className = 'tab';
        notesTab.className = 'tab active';
        remindersTab.className = 'tab';
        historyTab.className = 'tab';
        loadItems('note');
      });
      remindersTab.addEventListener('click', () => {
        allTab.className = 'tab';
        notesTab.className = 'tab';
        remindersTab.className = 'tab active';
        historyTab.className = 'tab';
        loadItems('reminder');
      });
      historyTab.addEventListener('click', () => {
        allTab.className = 'tab';
        notesTab.className = 'tab';
        remindersTab.className = 'tab';
        historyTab.className = 'tab active';
        loadItems('history');
      });

      if (currentEmail) {
        loadItems();
        scheduleReminders();
      }
    }

    init();
  </script>
</body>
</html>